package com.getgo.cloudtower.service;import com.amazonaws.AmazonClientException;import com.amazonaws.auth.AWSCredentials;import com.amazonaws.auth.AWSCredentialsProvider;import com.amazonaws.auth.profile.ProfileCredentialsProvider;import com.amazonaws.regions.Region;import com.amazonaws.regions.Regions;import com.amazonaws.services.cloudformation.AmazonCloudFormation;import com.amazonaws.services.cloudformation.AmazonCloudFormationClient;import com.amazonaws.services.cloudformation.model.ListStacksRequest;import com.amazonaws.services.cloudformation.model.StackStatus;import com.amazonaws.services.cloudformation.model.StackSummary;import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClient;import com.amazonaws.services.ec2.AmazonEC2;import com.amazonaws.services.ec2.AmazonEC2Client;import com.amazonaws.services.ec2.model.*;import com.amazonaws.services.ecs.AmazonECS;import com.amazonaws.services.ecs.AmazonECSClient;import com.amazonaws.services.ecs.model.Cluster;import com.amazonaws.services.elasticache.AmazonElastiCache;import com.amazonaws.services.elasticache.AmazonElastiCacheClient;import com.amazonaws.services.elasticache.model.CacheCluster;import com.amazonaws.services.elasticache.model.CacheNode;import com.amazonaws.services.lambda.AWSLambda;import com.amazonaws.services.lambda.AWSLambdaClient;import com.amazonaws.services.rds.AmazonRDS;import com.amazonaws.services.rds.AmazonRDSClient;import com.amazonaws.services.rds.model.DBInstance;import com.amazonaws.services.route53.AmazonRoute53;import com.amazonaws.services.route53domains.AmazonRoute53Domains;import com.amazonaws.services.route53domains.AmazonRoute53DomainsClient;import com.amazonaws.services.route53domains.model.DomainSummary;import com.amazonaws.services.s3.AmazonS3;import com.amazonaws.services.s3.AmazonS3Client;import com.amazonaws.services.s3.model.Bucket;import com.amazonaws.services.sns.AmazonSNS;import com.amazonaws.services.sns.AmazonSNSClient;import com.amazonaws.services.sns.model.Topic;import com.getgo.cloudtower.dao.AccountDAO;import com.getgo.cloudtower.dao.UsageDAO;import com.getgo.cloudtower.model.Account;import com.getgo.cloudtower.model.Usage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.PrintWriter;import java.io.StringWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Created by amirnashat on 9/1/16. */public class UsageService implements AWSService {	private Logger logger = LoggerFactory.getLogger(UsageService.class);	public enum Services {		CLOUDFORMATION( AmazonCloudFormation.ENDPOINT_PREFIX ) ,		DYNAMO ( AmazonDynamoDB.ENDPOINT_PREFIX ) ,		ECS ( AmazonECS.ENDPOINT_PREFIX ) ,		EC2 ( AmazonEC2.ENDPOINT_PREFIX ) ,		ELASTICACHE ( AmazonElastiCache.ENDPOINT_PREFIX ) ,		LAMBDA ( AWSLambda.ENDPOINT_PREFIX ) ,		RDS ( AmazonRDS.ENDPOINT_PREFIX ) ,		ROUTE53 (AmazonRoute53.ENDPOINT_PREFIX ) ,		SNS ( AmazonSNS.ENDPOINT_PREFIX ) ,		S3 ( AmazonS3.ENDPOINT_PREFIX ) ;				private final String service;				private Services(final String service) {			this.service = service;		}				public String toString() {			return service;		}	};	@Override	public void process() {				processUsageType(Services.CLOUDFORMATION.toString());		processUsageType(Services.DYNAMO.toString());		processUsageType(Services.ECS.toString());		processUsageType(Services.EC2.toString());		processUsageType(Services.ELASTICACHE.toString());		processUsageType(Services.LAMBDA.toString());		processUsageType(Services.RDS.toString());		processUsageType(Services.ROUTE53.toString());		processUsageType(Services.SNS.toString());		processUsageType(Services.S3.toString());	}	public void processUsageType(String usageName) {		List<Account> accounts = AccountDAO.getAccounts();		for (Account account: accounts) {			Integer accountId = account.getId();			/*	         * The ProfileCredentialsProvider will return your [default]	         * credential profile by reading from the credentials file located at	         * (~/.aws/credentials).	         */			AWSCredentialsProvider credentialsProvider = null;			AWSCredentials credentials = null;			try {				credentialsProvider = new ProfileCredentialsProvider( account.getName() );				credentials = new ProfileCredentialsProvider(account.getName()).getCredentials();			} catch (Exception e) {				throw new AmazonClientException("Cannot load the credentials from the credential profiles file. " + "Please make sure that your credentials file is at the correct " + "location (~/.aws/credentials), and is in valid format.", e);			}			// Create the AmazonEC2Client object so we can call various APIs.			AmazonEC2 ec2 = new AmazonEC2Client(credentials);			Region usEast1 = Region.getRegion(Regions.US_EAST_1);			ec2.setRegion(usEast1);			List<com.amazonaws.services.ec2.model.Region> regions = ec2.describeRegions().getRegions();			for ( com.amazonaws.services.ec2.model.Region region : regions ) {								try {					if ( usageName.equalsIgnoreCase(Services.EC2.toString() ) ) {												final AmazonEC2 ec2RegionClient = new AmazonEC2Client(credentials);						ec2RegionClient.setEndpoint( region.getEndpoint() );												Filter filter = new Filter();						filter.setName("instance-state-code");						filter.setValues(Arrays.asList("16", "80"));						DescribeInstancesRequest ec2InstanceRequest = new DescribeInstancesRequest();						ec2InstanceRequest.setFilters(Arrays.asList(filter));						DescribeInstancesResult ec2Instances = ec2RegionClient.describeInstances(ec2InstanceRequest);						Integer runningValue  = ec2Instances.getReservations().size();						List<AccountAttribute> ec2Attributes = ec2RegionClient.describeAccountAttributes().getAccountAttributes();						for (AccountAttribute ec2Attribute : ec2Attributes) {							if ( ec2Attribute.getAttributeName().equalsIgnoreCase("max-instances") ) {								Integer maxRunningValue = null;								List<AccountAttributeValue> attributeValues = ec2Attribute.getAttributeValues();								for (AccountAttributeValue attributeValue : attributeValues) {									maxRunningValue = Integer.valueOf(attributeValue.getAttributeValue());								}								Usage usagePOJO = new Usage();								usagePOJO.setAccountId(accountId);								usagePOJO.setRegionName(region.getRegionName());								usagePOJO.setUsageName(Services.EC2.toString());								usagePOJO.setRunningValue(runningValue);								usagePOJO.setMaxAllowedValue(maxRunningValue);								UsageDAO usageDAO = new UsageDAO();								Usage retrievedUsage = usageDAO.getUsageWithNameAndAccountAndRegion ( usagePOJO );																if ( retrievedUsage == null) {									usageDAO.insertUsage ( usagePOJO );								} else {									usagePOJO.setId( retrievedUsage.getId() );									usageDAO.updateUsage ( usagePOJO );								}															}						}																	} else if ( usageName.equalsIgnoreCase( Services.SNS.toString() ) ) {												AmazonSNS amazonSNS = new AmazonSNSClient( credentials );						List<Topic > topics = amazonSNS.listTopics().getTopics();																		//SNS service is only specific to an account and not a region so we can break out of region loop						break;										} else if ( usageName.equalsIgnoreCase( Services.ECS.toString() ) ) {												if ( isServiceSupportedForRegion( AmazonECS.ENDPOINT_PREFIX, region.getRegionName() ) ) {														AmazonECS ecs = Region.getRegion( Regions.fromName( region.getRegionName() ) ).createClient( AmazonECSClient.class, credentialsProvider, null );							List<Cluster> clusters = ecs.describeClusters().getClusters();														for ( Cluster cluster : clusters ) {								logger.info( "account <" + accountId + "> region <" + region.getEndpoint() + "> cluster <" + cluster.toString() + "> with services count <" + cluster.getActiveServicesCount().intValue() + ">" );							}														UsageDAO usageDAO = new UsageDAO();														Usage usagePOJO = new Usage();							usagePOJO.setRunningValue( clusters.size() );							usagePOJO.setAccountId( accountId );							usagePOJO.setRegionName( region.getRegionName() );							usagePOJO.setUsageName( Services.ECS.toString() );														Usage retrievedUsage = usageDAO.getUsageWithNameAndAccountAndRegion( usagePOJO );														if ( retrievedUsage == null ) {								usageDAO.insertUsage( usagePOJO );							} else {								usagePOJO.setId( retrievedUsage.getId() );								usageDAO.updateUsage( usagePOJO );							}													}											} else if ( usageName.equalsIgnoreCase( Services.LAMBDA.toString() ) ) {																		//IF THIS IS REGION MAKE SURE TO CALL CORRECT DAO METHOD												AWSLambda awsLambda = new AWSLambdaClient( credentials );											} else if ( usageName.equalsIgnoreCase( Services.ROUTE53.toString() ) ) {																		//IF THIS IS REGION MAKE SURE TO CALL CORRECT DAO METHOD												AmazonRoute53Domains route53 = new AmazonRoute53DomainsClient( credentials );						List<DomainSummary> domainSummaries = route53.listDomains().getDomains();												UsageDAO usageDAO = new UsageDAO();												Usage usagePOJO = new Usage();						usagePOJO.setRunningValue( domainSummaries.size() );						usagePOJO.setAccountId( accountId );						usagePOJO.setRegionName( region.getRegionName() );						usagePOJO.setUsageName( Services.ROUTE53.toString() );												Usage retrievedUsage = usageDAO.getUsageWithNameAndAccount( usagePOJO ).get( 0 );												if ( retrievedUsage == null ) {							usageDAO.insertUsage( usagePOJO );						} else {							usagePOJO.setId( retrievedUsage.getId() );							usageDAO.updateUsage( usagePOJO );						}												//Route53 service is only specific to an account and not a region so we can break out of region loop						break;											} else if ( usageName.equalsIgnoreCase( Services.ELASTICACHE.toString() ) ) {												AmazonElastiCache amazonElastiCache = new AmazonElastiCacheClient( credentials );						List<CacheCluster> cacheClusters = amazonElastiCache.describeCacheClusters().getCacheClusters();												UsageDAO usageDAO = new UsageDAO();												for ( CacheCluster cluster : cacheClusters ) {														List<CacheNode> cacheNodes = cluster.getCacheNodes();							Usage usagePOJO = new Usage();							usagePOJO.setAccountId( accountId );							usagePOJO.setRegionName( region.getRegionName() );							usagePOJO.setUsageName( Services.ELASTICACHE.toString() );							usagePOJO.setRunningValue( cacheNodes.size() );														Usage retrievedUsage = usageDAO.getUsageWithNameAndAccountAndRegion( usagePOJO );														if ( retrievedUsage == null ) {								usageDAO.insertUsage( usagePOJO );							} else {								usagePOJO.setId( retrievedUsage.getId() );								usageDAO.updateUsage( usagePOJO );							}						}											} else if ( usageName.equalsIgnoreCase( Services.RDS.toString() ) ) {														UsageDAO usageDAO = new UsageDAO();														//AmazonRDS rds = Region.getRegion( Regions.fromName( region.getRegionName() ) ).createClient( AmazonRDSClient.class, credentialsProvider, null );							AmazonRDS rds = new AmazonRDSClient( credentials);							List < DBInstance > dbInstances = rds.describeDBInstances().getDBInstances();														logger.info( "for region <" + region.getEndpoint() + "> snapshots <" + dbInstances.size() + ">" );														Usage usagePOJO = new Usage();							usagePOJO.setAccountId( accountId );							usagePOJO.setRegionName( region.getRegionName() );							usagePOJO.setUsageName( Services.RDS.toString() );							usagePOJO.setRunningValue( dbInstances.size() );														Usage retrievedUsage = usageDAO.getUsageWithNameAndAccount( usagePOJO ).get( 0 );														if ( retrievedUsage == null ) {								usageDAO.insertUsage( usagePOJO );							} else {								usagePOJO.setId( retrievedUsage.getId() );								usageDAO.updateUsage( usagePOJO );							}														//RDS is only specific to an account and not a region so we can break ouf of region loop							break;												} else if ( usageName.equalsIgnoreCase( Services.DYNAMO.toString() ) ) {												if ( isServiceSupportedForRegion( AmazonDynamoDB.ENDPOINT_PREFIX, region.getRegionName() ) ) {														UsageDAO usageDAO = new UsageDAO();							AmazonDynamoDB dynamoDB = Region.getRegion( Regions.fromName( region.getRegionName() ) ).createClient( AmazonDynamoDBClient.class, credentialsProvider, null );							List<String> tableNames = dynamoDB.listTables().getTableNames();														logger.info ("for region <" + region.getEndpoint() + "> dynamo db number of tables is <" + tableNames.size() + ">");														Usage usagePOJO = new Usage();							usagePOJO.setAccountId( accountId );							usagePOJO.setRegionName( region.getRegionName() );							usagePOJO.setUsageName( Services.DYNAMO.toString() );							usagePOJO.setRunningValue( tableNames.size() );														Usage retrievedUsage = usageDAO.getUsageWithNameAndAccount( usagePOJO ).get( 0 );														if ( retrievedUsage == null ) {								usageDAO.insertUsage( usagePOJO );							} else {								usagePOJO.setId( retrievedUsage.getId() );								usageDAO.updateUsage( usagePOJO );							}						}											} else if ( usageName.equalsIgnoreCase( Services.S3.toString() ) ) {												AmazonS3 s3 = new AmazonS3Client(credentials);						List<Bucket> buckets = s3.listBuckets();						logger.info("region <"+region.getEndpoint()+"> total of buckets is <"+buckets.size()+">");												Usage usagePOJO = new Usage();						usagePOJO.setAccountId( accountId );						usagePOJO.setRegionName( region.getRegionName() );						usagePOJO.setUsageName( Services.S3.toString() );						usagePOJO.setRunningValue( buckets.size() );						usagePOJO.setMaxAllowedValue( null );												UsageDAO usageDAO = new UsageDAO();						Usage retrievedUsage = usageDAO.getUsageWithNameAndAccountAndRegion( usagePOJO );												if ( retrievedUsage == null ) {							usageDAO.insertUsage( usagePOJO );						} else {							usagePOJO.setId( retrievedUsage.getId() );							usageDAO.updateUsage( usagePOJO );						}												//S3 service is only specific to an account and not a region so we can break out of region loop						break;					} else if ( usageName.equalsIgnoreCase(Services.CLOUDFORMATION.toString() ) ) {												AmazonCloudFormation cloudFormation = new AmazonCloudFormationClient(credentials);												//CloudFormation Stacks are counted per account and NOT per region						//list only active stacks						ListStacksRequest cloudFormationStacksRequest = new ListStacksRequest();						cloudFormationStacksRequest.setStackStatusFilters(								Arrays.asList(										StackStatus.CREATE_COMPLETE.toString() ,										StackStatus.UPDATE_COMPLETE.toString() ,										StackStatus.ROLLBACK_COMPLETE.toString() ,										StackStatus.DELETE_IN_PROGRESS.toString() ,										StackStatus.DELETE_FAILED.toString() ,										StackStatus.CREATE_FAILED.toString() ) );						List<StackSummary> cloudFormationStacks = cloudFormation.listStacks( cloudFormationStacksRequest ).getStackSummaries();												Usage usagePOJO = new Usage();						usagePOJO.setAccountId( accountId );						usagePOJO.setRegionName( region.getRegionName() );						usagePOJO.setUsageName( Services.CLOUDFORMATION.toString() );						usagePOJO.setRunningValue( cloudFormationStacks.size() );						usagePOJO.setMaxAllowedValue( null );												UsageDAO usageDAO = new UsageDAO();						Usage retrievedUsage = usageDAO.getUsageWithNameAndAccountAndRegion( usagePOJO );												if ( retrievedUsage == null ) {							usageDAO.insertUsage( usagePOJO );						} else {							usagePOJO.setId( retrievedUsage.getId() );							usageDAO.updateUsage( usagePOJO );						}												//CloudFormation is only specific to an account and not a region so we can break ouf of region loop						break;											}									} catch ( Exception exception ) {					StringWriter writer = new StringWriter();					PrintWriter printWriter = new PrintWriter( writer );					exception.printStackTrace( printWriter );					printWriter.flush();					String stackTrace = writer.toString();					logger.error(stackTrace);				}			}		}	}	@Override	public List<Usage> retrieve() {		UsageDAO usageDAO = new UsageDAO();		List<Usage> usages = usageDAO.getUsages();		return usages;	}		public List<Usage> retrieveForUsageType( String usageType ) {				List usages = retrieveForUsageType( usageType );		return usages;	}		public Usage retrieveForAccountAndName ( Usage usage ) {			UsageDAO usageDao = new UsageDAO();		Usage retrievedUsageObject = usageDao.getUsageWithNameAndAccount( usage ).get( 0 );		return retrievedUsageObject;	}		public void updateUsageMaxAllowedValueForService( Usage usage) {		UsageDAO usageDAO = new UsageDAO();		usageDAO.updateUsage( usage );	}			private boolean isServiceSupportedForRegion(String serviceName, String regionName) {				if ( Region.getRegion( Regions.fromName( regionName ) ).isServiceSupported( serviceName ) ) {			return true;		}				return false;	}		public static final List<String> retrieveServices() {		//list of services		List<String> usagesList = new ArrayList();		usagesList.add( Services.CLOUDFORMATION.toString() );		usagesList.add( Services.DYNAMO.toString() );		usagesList.add( Services.EC2.toString() );		usagesList.add( Services.ECS.toString() );		usagesList.add( Services.ELASTICACHE.toString() );		usagesList.add( Services.LAMBDA.toString() );		usagesList.add( Services.RDS.toString() );		usagesList.add( Services.ROUTE53.toString() );		usagesList.add( Services.S3.toString() );		usagesList.add( Services.SNS.toString() );					return usagesList;	}}