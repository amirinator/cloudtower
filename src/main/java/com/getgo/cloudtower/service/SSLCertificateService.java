package com.getgo.cloudtower.service;import com.amazonaws.AmazonClientException;import com.amazonaws.auth.AWSCredentials;import com.amazonaws.auth.AWSCredentialsProvider;import com.amazonaws.auth.profile.ProfileCredentialsProvider;import com.amazonaws.regions.Region;import com.amazonaws.regions.Regions;import com.amazonaws.services.certificatemanager.AWSCertificateManager;import com.amazonaws.services.certificatemanager.AWSCertificateManagerClient;import com.amazonaws.services.certificatemanager.model.CertificateDetail;import com.amazonaws.services.certificatemanager.model.CertificateSummary;import com.amazonaws.services.certificatemanager.model.DescribeCertificateRequest;import com.amazonaws.services.certificatemanager.model.ListCertificatesRequest;import com.amazonaws.services.ec2.AmazonEC2;import com.amazonaws.services.ec2.AmazonEC2Client;import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancing;import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancingClient;import com.amazonaws.services.elasticloadbalancing.model.ListenerDescription;import com.amazonaws.services.elasticloadbalancing.model.LoadBalancerDescription;import com.getgo.cloudtower.dao.AccountDAO;import com.getgo.cloudtower.dao.SSLCertificateDAO;import com.getgo.cloudtower.model.Account;import com.getgo.cloudtower.model.SSLCertificate;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.net.ssl.*;import javax.security.cert.X509Certificate;import java.io.PrintWriter;import java.io.StringWriter;import java.net.InetSocketAddress;import java.security.SecureRandom;import java.sql.Date;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by amirnashat on 7/28/16. */public class SSLCertificateService implements AWSService {	final Logger logger = LoggerFactory.getLogger(SSLCertificateService.class);		public enum CertificateType {				ACM ( "ACM"),		GETGO ( "GetGo");				private final String type;				private CertificateType ( final String type ) {			this.type = type;		}				public String toString() {			return type;		}	}		@Override	public void process() {		SSLCertificateDAO dao = new SSLCertificateDAO();		//First query database and obtain a list of the		List<Account> accounts = AccountDAO.getAccounts();		for (Account account: accounts) {			Integer accountId = account.getId();			/*	         * The ProfileCredentialsProvider will return your [default]	         * credential profile by reading from the credentials file located at	         * (~/.aws/credentials).	         */						AWSCredentialsProvider credentialsProvider = null;			AWSCredentials credentials = null;			try {				credentialsProvider = new ProfileCredentialsProvider( account.getName() );				credentials = new ProfileCredentialsProvider(account.getName()).getCredentials();			} catch (Exception e) {				throw new AmazonClientException("Cannot load the credentials from the credential profiles file. " + "Please make sure that your credentials file is at the correct " + "location (~/.aws/credentials), and is in valid format.", e);			}						// Create the AmazonEC2Client object so we can call various APIs.			AmazonEC2 ec2 = new AmazonEC2Client(credentials);			Region usEast1 = Region.getRegion(Regions.US_EAST_1);			ec2.setRegion(usEast1);			List<com.amazonaws.services.ec2.model.Region> regions = ec2.describeRegions().getRegions();			for (com.amazonaws.services.ec2.model.Region region : regions) {				String regionName = region.getRegionName();								String hostname = null;				try {										AmazonElasticLoadBalancing elbClient= new AmazonElasticLoadBalancingClient(credentials);					List<LoadBalancerDescription> elbs = elbClient.describeLoadBalancers().getLoadBalancerDescriptions();										for (LoadBalancerDescription elb : elbs) {						hostname = elb.getDNSName();						int port = 443;						int connectionTimeout = 10000; //10000 milliseconds						Date certificateExpirationDate = null;						List<ListenerDescription> elbListenerDescriptions = elb.getListenerDescriptions();						for (ListenerDescription elbListenerDescription : elbListenerDescriptions) {														if (elbListenerDescription.getListener().getProtocol().equalsIgnoreCase("HTTPS")) {																if(elbListenerDescription.getListener().getLoadBalancerPort().intValue() != 443) {									port = elbListenerDescription.getListener().getLoadBalancerPort().intValue();								}																SSLSocket socket = null;								X509Certificate sslCertificate = null;								SSLContext ctx = null;																try {																		//configure the SSLContext with the 'DefaultTrustManager' private class to override									//SSL exceptions from expired certificates																		ctx = SSLContext.getInstance( "TLS" );									ctx.init( new KeyManager[0], new TrustManager[]{ new DefaultTrustManager() }, new SecureRandom() );									SSLContext.setDefault( ctx );																		socket = ( SSLSocket ) SSLSocketFactory.getDefault().createSocket();									socket.connect( new InetSocketAddress( hostname, port ), connectionTimeout );									socket.startHandshake();									sslCertificate = socket.getSession().getPeerCertificateChain()[0];									certificateExpirationDate = new Date( sslCertificate.getNotAfter().getTime() );																		SSLCertificate certificatePOJO = new SSLCertificate();									certificatePOJO.setExpirationDate( certificateExpirationDate );									certificatePOJO.setHostname( hostname );									certificatePOJO.setAccountId( accountId );									certificatePOJO.setCertificateType( CertificateType.GETGO.toString() );									certificatePOJO.setRegionName( regionName );																		SSLCertificate retrievedSSLCertificateRecord = dao.getSSLCertificateWithHostnameAndAccountId( certificatePOJO );																		if ( retrievedSSLCertificateRecord == null ) {										dao.insertSSLCertificate( certificatePOJO );									} else {										certificatePOJO.setId( retrievedSSLCertificateRecord.getId() );										dao.updateSSLCertificate( certificatePOJO );									}																	} catch (Exception exception) {																		StringWriter writer = new StringWriter();									PrintWriter printWriter = new PrintWriter( writer );									exception.printStackTrace( printWriter );									printWriter.flush();																		String stackTrace = writer.toString();									logger.error("For host <" + hostname + "> on port <" + port + "> got the following exception:\n" + stackTrace);																	} finally {																		socket.close();																	}							}						}											}				} catch (Exception exception) {					StringWriter writer = new StringWriter();					PrintWriter printWriter = new PrintWriter( writer );					exception.printStackTrace( printWriter );					printWriter.flush();					String stackTrace = writer.toString();				}								//process AWS ACM certs				processACM();							}		}	}			public void processACM() {				SSLCertificateDAO dao = new SSLCertificateDAO();				//First query database and obtain a list of the		List<Account> accounts = AccountDAO.getAccounts();		for (Account account: accounts) {			Integer accountId = account.getId();			/*	         * The ProfileCredentialsProvider will return your [default]	         * credential profile by reading from the credentials file located at	         * (~/.aws/credentials).	         */						AWSCredentialsProvider credentialsProvider = null;			AWSCredentials credentials = null;			try {				credentialsProvider = new ProfileCredentialsProvider( account.getName() );				credentials = new ProfileCredentialsProvider( account.getName() ).getCredentials();			} catch ( Exception e ) {				throw new AmazonClientException( "Cannot load the credentials from the credential profiles file. " + "Please make sure that your credentials file is at the correct " + "location (~/.aws/credentials), and is in valid format.", e );			}						// Create the AmazonEC2Client object so we can call various APIs.			AmazonEC2 ec2 = new AmazonEC2Client( credentials );			Region usEast1 = Region.getRegion( Regions.US_EAST_1 );			ec2.setRegion( usEast1 );			List < com.amazonaws.services.ec2.model.Region > regions = ec2.describeRegions().getRegions();						for ( com.amazonaws.services.ec2.model.Region region : regions ) {								String regionName = region.getRegionName();				//Retrieve ACM certificates and persist them								try {										if ( Region.getRegion( Regions.fromName( regionName ) ).isServiceSupported( AWSCertificateManager.ENDPOINT_PREFIX.toString() ) ) {												AWSCertificateManager acm = Region.getRegion( Regions.fromName( region.getRegionName() ) ).createClient( AWSCertificateManagerClient.class, credentialsProvider, null );						ListCertificatesRequest certificatesRequest = new ListCertificatesRequest();						List < CertificateSummary > certificateSummaries = acm.listCertificates( certificatesRequest ).getCertificateSummaryList();						for ( CertificateSummary certificateSummary : certificateSummaries ) {							String certificateARN = certificateSummary.getCertificateArn();							DescribeCertificateRequest describeCertificateRequest = new DescribeCertificateRequest();							describeCertificateRequest.setCertificateArn( certificateARN );							CertificateDetail certificateDetail = acm.describeCertificate( describeCertificateRequest ).getCertificate();														//Persist the certificate							SSLCertificate acmSSLCertificate = new SSLCertificate();							acmSSLCertificate.setCertificateType( CertificateType.ACM.toString() );							acmSSLCertificate.setAccountId( accountId );							acmSSLCertificate.setRegionName( regionName );							acmSSLCertificate.setHostname( certificateDetail.getCertificateArn() );														if ( certificateDetail.getNotAfter() != null ) {								acmSSLCertificate.setExpirationDate( new java.sql.Date( certificateDetail.getNotAfter().getTime() ) );							} else {								acmSSLCertificate.setExpirationDate( null );							}														SSLCertificate retrievedACMSSLCertificateRecord = dao.getSSLCertificateWithHostnameAndAccountId( acmSSLCertificate );														if ( retrievedACMSSLCertificateRecord == null ) {								dao.insertSSLCertificate( acmSSLCertificate );							} else {								acmSSLCertificate.setId( retrievedACMSSLCertificateRecord.getId() );								dao.updateSSLCertificate( acmSSLCertificate );							}													}											}									} catch (IllegalArgumentException illegalArguementException) {										logger.error(illegalArguementException.getMessage());								} catch (Exception exception) {										StringWriter writer = new StringWriter();					PrintWriter printWriter = new PrintWriter( writer );					exception.printStackTrace( printWriter );					printWriter.flush();										String stackTrace = writer.toString();					logger.error(stackTrace);									}			}		}		}	@Override	public List<SSLCertificate> retrieve() {		AccountService accountService = new AccountService();		SSLCertificateDAO dao = new SSLCertificateDAO();		List<SSLCertificate> sslCertificates = dao.getSSLCertificates();		for (SSLCertificate sslCertificate : sslCertificates) {			Integer accountId = sslCertificate.getAccountId();			String accountName = accountService.getAccountWithAccountId(accountId).getName();		}				return sslCertificates;	}	public Map<SSLCertificate,String> retrieveWithAccountName() {		AccountService accountService = new AccountService();		List<SSLCertificate> sslCertificates  = retrieve();		Map<SSLCertificate,String> sslCertificatesWithAccountName = new HashMap<SSLCertificate,String>();		for (SSLCertificate sslCertificate : sslCertificates ) {			String accountName = accountService.getAccountWithAccountId(sslCertificate.getAccountId()).getName();			sslCertificatesWithAccountName.put(sslCertificate,accountName);		}		return sslCertificatesWithAccountName;	}			/*	 * The following is needed to override the SSL exceptions when examing self signed certs	 */	private static class DefaultTrustManager implements X509TrustManager {				@Override		public void checkClientTrusted ( java.security.cert.X509Certificate[] x509Certificates, String s ) throws java.security.cert.CertificateException {					}				@Override		public void checkServerTrusted ( java.security.cert.X509Certificate[] x509Certificates, String s ) throws java.security.cert.CertificateException {					}				@Override		public java.security.cert.X509Certificate[] getAcceptedIssuers() {			return null;		}	}}