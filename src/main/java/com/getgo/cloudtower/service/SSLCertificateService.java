package com.getgo.cloudtower.service;import com.amazonaws.AmazonClientException;import com.amazonaws.auth.AWSCredentials;import com.amazonaws.auth.profile.ProfileCredentialsProvider;import com.amazonaws.regions.Region;import com.amazonaws.regions.Regions;import com.amazonaws.services.ec2.AmazonEC2;import com.amazonaws.services.ec2.AmazonEC2Client;import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancing;import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancingClient;import com.amazonaws.services.elasticloadbalancing.model.ListenerDescription;import com.amazonaws.services.elasticloadbalancing.model.LoadBalancerDescription;import com.getgo.cloudtower.dao.AccountDAO;import com.getgo.cloudtower.dao.SSLCertificateDAO;import com.getgo.cloudtower.model.Account;import com.getgo.cloudtower.model.SSLCertificate;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.net.ssl.*;import javax.security.cert.X509Certificate;import java.io.PrintWriter;import java.io.StringWriter;import java.net.InetSocketAddress;import java.security.SecureRandom;import java.sql.Date;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by amirnashat on 7/28/16. */public class SSLCertificateService implements AWSService {	final Logger logger = LoggerFactory.getLogger(SSLCertificateService.class);		@Override	public void process() {		SSLCertificateDAO dao = new SSLCertificateDAO();		//First query database and obtain a list of the		List<Account> accounts = AccountDAO.getAccounts();		for (Account account: accounts) {			Integer accountId = account.getId();			/*	         * The ProfileCredentialsProvider will return your [default]	         * credential profile by reading from the credentials file located at	         * (~/.aws/credentials).	         */			AWSCredentials credentials = null;			try {				credentials = new ProfileCredentialsProvider(account.getName()).getCredentials();			} catch (Exception e) {				throw new AmazonClientException("Cannot load the credentials from the credential profiles file. " + "Please make sure that your credentials file is at the correct " + "location (~/.aws/credentials), and is in valid format.", e);			}			// Create the AmazonEC2Client object so we can call various APIs.			AmazonEC2 ec2 = new AmazonEC2Client(credentials);			Region usEast1 = Region.getRegion(Regions.US_EAST_1);			ec2.setRegion(usEast1);			List<com.amazonaws.services.ec2.model.Region> regions = ec2.describeRegions().getRegions();			for (com.amazonaws.services.ec2.model.Region region : regions) {				String regionName = region.getRegionName();				AmazonElasticLoadBalancing elbClient= new AmazonElasticLoadBalancingClient(credentials);				List<LoadBalancerDescription> elbs = elbClient.describeLoadBalancers().getLoadBalancerDescriptions();				try {					for (LoadBalancerDescription elb : elbs) {						String hostname = elb.getDNSName();						int port = 443;						int connectionTimeout = 3000; //3000 milliseconds						Date certificateExpirationDate = null;						List<ListenerDescription> elbListenerDescriptions = elb.getListenerDescriptions();						for (ListenerDescription elbListenerDescription : elbListenerDescriptions) {														if (elbListenerDescription.getListener().getProtocol().equalsIgnoreCase("HTTPS")) {																//logger.info("Elb listener descript <"+elbListenerDescription.toString()+">");																if(elbListenerDescription.getListener().getLoadBalancerPort().intValue() != 443) {									port = elbListenerDescription.getListener().getLoadBalancerPort().intValue();								}																SSLSocket socket = null;								X509Certificate sslCertificate = null;								SSLContext ctx = null;																try {																		//configure the SSLContext with the 'DefaultTrustManager' private class to override									//SSL exceptions from expired certificates																		ctx = SSLContext.getInstance( "TLS" );									ctx.init( new KeyManager[0], new TrustManager[]{ new DefaultTrustManager() }, new SecureRandom() );									SSLContext.setDefault( ctx );																		socket = ( SSLSocket ) SSLSocketFactory.getDefault().createSocket();									socket.connect( new InetSocketAddress( hostname, port ), connectionTimeout );									socket.startHandshake();									sslCertificate = socket.getSession().getPeerCertificateChain()[0];									certificateExpirationDate = new Date( sslCertificate.getNotAfter().getTime() );								} finally {									socket.close();								}							}						}						SSLCertificate certificatePOJO = new SSLCertificate();						certificatePOJO.setExpirationDate(certificateExpirationDate);						certificatePOJO.setHostname(hostname);						certificatePOJO.setAccountId(accountId);						certificatePOJO.setRegionName(regionName);												SSLCertificate retrievedSSLCertificateRecord = dao.getSSLCertificateWithHostnameAndAccountId(certificatePOJO);						if (retrievedSSLCertificateRecord == null) {							dao.insertSSLCertificate(certificatePOJO);						} else {							certificatePOJO.setId( retrievedSSLCertificateRecord.getId() );							dao.updateSSLCertificate(certificatePOJO);						}					}				} catch (Exception exception) {					StringWriter writer = new StringWriter();					PrintWriter printWriter = new PrintWriter( writer );					exception.printStackTrace( printWriter );					printWriter.flush();					String stackTrace = writer.toString();					logger.error(stackTrace);				}			}		}	}		@Override	public List<SSLCertificate> retrieve() {		AccountService accountService = new AccountService();		SSLCertificateDAO dao = new SSLCertificateDAO();		List<SSLCertificate> sslCertificates = dao.getSSLCertificates();		for (SSLCertificate sslCertificate : sslCertificates) {			Integer accountId = sslCertificate.getAccountId();			String accountName = accountService.getAccountWithAccountId(accountId).getName();		}				return sslCertificates;	}	public Map<SSLCertificate,String> retrieveWithAccountName() {		AccountService accountService = new AccountService();		List<SSLCertificate> sslCertificates  = retrieve();		Map<SSLCertificate,String> sslCertificatesWithAccountName = new HashMap<SSLCertificate,String>();		for (SSLCertificate sslCertificate : sslCertificates ) {			String accountName = accountService.getAccountWithAccountId(sslCertificate.getAccountId()).getName();			sslCertificatesWithAccountName.put(sslCertificate,accountName);		}		return sslCertificatesWithAccountName;	}			private static class DefaultTrustManager implements X509TrustManager {				@Override		public void checkClientTrusted ( java.security.cert.X509Certificate[] x509Certificates, String s ) throws java.security.cert.CertificateException {					}				@Override		public void checkServerTrusted ( java.security.cert.X509Certificate[] x509Certificates, String s ) throws java.security.cert.CertificateException {					}				@Override		public java.security.cert.X509Certificate[] getAcceptedIssuers() {			return null;		}	}}